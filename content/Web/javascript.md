---
title: "JavaScript Basics"
date: 2017-03-22
---

# JavaScript 对象

## 基本包装类型

ECMAScript 提供了3个特殊的引用类型：Boolean、Number 和 String。
引用类型与基本包装类型的主要区别就是**对象的生存期**。
> 使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着不能在运行时为基本类型值添加属性和方法。

使用 new 调用基本包装类型的构造函数，与直接调用同名的转型函数不一样。使用转型函数得到的对象仍然为基本类型。
不建议显式地创建基本包装类型的对象。

### Boolean 类型

基本类型与引用类型的布尔值的区别：
- 布尔表达式中的所有对象都会被转换为 true，所以即便 Boolean 对象的值为 false，在布尔表达式中仍然为 true。
- typeof 操作符对基本类型返回 "boolean"，而对引用类型返回 "object"。
- 由于 Boolean 对象是 Boolean 类型的实例，所以使用 instanceof 操作符测试 Boolean 对象会返回 true，而测试基本类型的布尔值则返回 false。

### Number 类型

Number 类型提供了操作数值的方法。
- `toExponential` 返回指数（科学记数法）表示方法的数值的字符串。
- `toFixed()` 返回固定小数点位数表示方法的数值的字符串。
- `toPrecision()` 返回特定精度的数值的字符串。
- `valueOf()` 返回基本类型值
- `toLocaleString()` `toString()` 返回数值的字符串表示。

### String 类型

String 类型实例同样继承了 `valueOf()` `toLocaleString()` `toString()` 方法，都返回对象所表示的基本字符串值。

**字符方法**
两个用于访问字符串中特定字符的方法：`charAt()` 和 `charCodeAt()`，两个方法都接收一个参数，即基于0的字符位置。
ECMAScript 5定义了另一个访问个别字符的方法，在支持此方法的浏览器中，可以使用方括号加数字索引来反问字符串中的特定字符。

**字符串操作方法**
拼接字符串 `concat()`，该方法可以接受任意多个参数。
三个基于子字符串创建新字符串的方法：`slice()` `substr()` `substring()`。
字符串位置方法：`indexOf()` `lastIndexOf()`
`trim()` 方法：删除前置及后缀的所有空格。
大小写转换方法：`toLowerCase()` `toLocaleLowerCase()` `toUpperCase()` `toLocaleUpperCase()`
模式匹配方法：`match()` `search()` `replace()` `split()`
`localeCompare()`：比较两个字符串，并返回-1，0，或1。
`fromCharCode()`：接收一或多个字符编码，然后将它们转换成一个字符串。

## 单体内置对象

**内置对象**：由 ECMAScript 实现提供的、不依赖于宿主环境的对象，这些对象在 ECMAScript 程序执行之前就已经存在了。开发者不必显式地实例化内置对象，因为它们已经被实例化了。

### Global 对象

不属于任何其他对象的属性和方法，最终都是 Global 对象的属性和方法。事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是 Global 对象的属性。

URI 编码方法
`encodeURI()` `encodeURIComponent()` 方法可以对 URI (Uniform Resource Identifiers, 通用资源标识符) 进行编码，以便发送给浏览器。有效的 URI 中不能包含某些字符，于是这两个方法就对 URI 进行编码，使用特殊的 UTF-8 编码替换掉所有无效的字符，从而让浏览器能够接受和理解。

`decodeURI()` `decodeURIComponent()` 解码方法和编码方法相对应。

`eval()` 方法像是一个完整的 ECMAScript 解析器，只接受一个参数，即要执行的 ECMAScript 字符串。

### Math 对象

Math 对象的属性，大多是数学计算中可能会用到的一些特殊值。
`min()` 和 `max()` 方法
舍入方法：`Math.ceil()` `Math.floor()` `Math.round()`
`random()` 方法返回大于等于0小于1的一个随机数。
要得到特定范围的随机值 `值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)`

## Date

构建 Date 类型
`var now = new Data()` 为传入参数将自动返回当前的日期和时间，为距 UTC 1970-1-1午夜零时的时间戳（毫秒）。若需创建特定日期和时间创建日期对象，需传入时间戳。

两个方法：输出因浏览器而异。
`Data.parse()` 接收日期的字符串参数然后返回时间戳。参数格式因本地语言设置有关。
`Data.UTC()` 接收的参数分别为年、月（0开始）、日、时、分、秒、毫秒。返回时间戳。

ECMAScript 5 新引入的方法
`Data.now()` 调用该方式时的日期和时间的毫秒数。

继承方法
Date 类型继承了 `toLocaleString()` `toString()` `valueOf()` 的方法，但输出值与其他类型的方法不同。

日期格式化方法
`toDateString()`
`toTimeString()`
`toLocaleDateString()`
`toLocaleTimeString()`
`toUTCString()`

日期/时间组件方法：直接取得和设置日期值中特定部分的方法 `get/set*`。

## RegExp 类型

字面量 `/pattern/flags`
构造函数 `new RegExp(pattern[, flags])`

``` javascript
/ab+c/i;
new RegExp('ab+c', 'i');
new RegExp(/ab+c/, 'i');
```

**pattern** 任何简单或复杂的正则表达式，包含字符类、限定符、分组、先前查找、反向引用。构造函数下，pattern 也可以为字符串模式。
**flags** 每个正则表达式都可以带一个或多个标志（flags），用来标明正则表达式的行为。
- g：全局，遍历所有匹配项。
- i：不区分大小写。
- m：多行模式。

元字符：模式中所有元字符都必须转义，包括 `( [ { \ ^ $ | ) ? * + . ] }`。

### RegExp 实例属性

RegExp 实例属性可以取得有关模式的各种信息：
- **global** 布尔值，是否设置了 g 标志。
- **ignore**Case 布尔值，是否设置了 i 标志。
- **lastIndex** 整数，表示开始搜索下一个匹配项的字符位置，从0算起。
- **multiline** 布尔值，是否设置了 m 标志。
- **source** 正则表达式的字符串表示，按照**字面量形式**返回。

### RegExp 构造函数属性

RegExp 构造函数包含的一些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。这些属性分别有一个长属性名和一个短属性名。短属性名大都不是有效的 ECMAScript 标识符，因此必须通过方括号语法来访问它们。除此之外还有用9个用于存储捕获组的构造函数属性。访问这些属性的语法是 `RegExp.$1/2/.../9`。

长属性名 | 短属性名 | 说明
:-------|:--------|:----
`input` | `$_` | 最近一次要匹配的字符串
`lastMatch` | `$&` | 最近一次的匹配项
`lastParen` | `$+` | 最近一次匹配的捕获组
`leftContext` | \`$\`\` | input 字符串中 lastMatch 之前的文本
`multiline` | `$*` | 布尔值，表示是否所有表达式都使用多行模式
`rightContext` | `$'` | input 字符串中 lastMatch 之后的文本

### 模式的局限性

不支持的正则表达式特性：
- 匹配字符串开始和结尾的 `\A` 和 `\Z` 锚。（支持 `^` 和 `$` 匹配）
- 向后查找（但完全支持向前查找）
- 并集和交集类
- 原子组
- Unicode 支持（单个字符除外，如 \uFFFF）
- 命名的捕获组
- `s`（单行） 和 `x`（无间隔） 匹配模式
- 条件匹配
- 正则表达式注释

## 总结

学习 JavaScript 编程基础已有一段时间，觉得 JavaScript 的难点在于几个难以理解的抽象概念和应对一些语言设计上的“坑”。理解了 JS 语言中的这几个概念，例如，对象，类，原型，原型链，作用域，闭包，继承等，也就算是入门了吧。实际上，这些概念也就是面向对象和函数式编程语言对于初学编程的人来说难以理解的点。只不过在 JS 上，有其特殊性。

# JavaScript 作用域

来源：你不知道的 JS 上 --- 作用域

传统编译语言的流程中，源码在执行前会经历三个步骤（编译）：
- **分词/词法分析（Tokenizing/Lexing）**：将由字符组成的字符串分解成有意义的代码块（词法单元）。
- **解析/语法分析（Parsing）**：将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的数（抽象语法树，Abstract Syntax Tree, AST）。
- **代码生成**：将 AST 转换为可执行代码。

对 JS 来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时间内。任何 JS 代码片段在执行前都要进行编译。编译后通常马上执行它。

代码编译到执行关键的三个部件：
- **引擎**：从头到尾负责整个 JS 程序的编译及执行过程。
- **编译器**：负责语法分析及代码生成等。
- **作用域**：负责收集并维护有所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

**变量的赋值操作**会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。

理解两种查询方式：
- **LHS 查询**，视图找到变量的容器本身，然后对其赋值。赋值操作的目标是谁？
- **RHS 查询**，取到它的源值，意味着得到某某的值。谁是赋值操作的源头？

当变量出现在赋值操作的左侧时，进行 LHS 查询，出现在右侧（非左侧）则进行 RHS 查询。RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是视图找到变量的容器本身，从而可以对其赋值。

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。
**遍历嵌套作用域链**：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到与否，查找过程都会停止。

**ReferenceError**
如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。但是，当引擎执行 LHS 查询时，如果在顶层中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非“严格模式”下。在严格模式下，会禁止自动或隐式地创建全局变量。因此，在严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎同样抛出 ReferenceError 异常。

**TypeError**
如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如视图对一个非函数类型的值进行函数调用，或者引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError。

总结：作用域是学习编程过程中需要着重理解的概念之一。

# jQuery

jQuery 的优势：
- 轻量级：采用 UglifyJS 压缩，保持在 30KB 左右。
- 强大的选择器：允许开发者使用 CSS 几乎所有选择器，以及独创的高级而复杂的选择器。开发者还可以编写自己的选择器。
- 出色的 DOM 操作的封装。
- 可靠的事件处理机制。
- 完善的 Ajax。所有 ajax 的操作都封装到一个函数 `$.ajax()` 里，使得开发者处理 ajax 的时候能够专心处理业务逻辑。
- 不污染顶层变量。该特性使得 jQuery 可以与其他 JS 库共存。
- 出色的浏览器兼容性。
- 链式操作方法。jQuery 最有特色的莫过于它的链式操作方式，即对发生在同一个 jQuery 对象上的一组动作，可以直接连写而无需重复获取对象。
- 隐式迭代。jQuery 里的方法都被设计成自动操作对象集合，而不是单独的对象。
- 行为层与结构层的分离。开发者可以使用 jQuery 选择器选中元素，然后直接给元素添加事件。
- 丰富的插件支持。jQuery 的易扩展性，吸引了来自全球的开发者来编写 jQuery 的扩展插件。
- 完善的文档。包括长期更新的中文文档。
- 开源。

来源：《锋利的 jQeury 第二版》

# JavaScript：解构赋值

**解构赋值句法**是一个能够从数组或者对象中提取出数据并赋值到不同变量的表达式。

## 数组解构赋值

基本赋值：数组中的元素依次赋值给左边的变量。如果变量个数超出了数组长度，那么超出部分的变量赋值为 `undefined`。如果变量个数不及数组长度，多余的数组元素不赋值给变量。

``` javascript
var foo = ["one", "two", "three"];
// 变量个数等于 foo 长度
var [One, Two, Three] = foo;
// 变量个数小于 foo 长度
var [One, Two] = foo;
// 变量个数大于 foo 长度
var [One, Two, Three, Four] = foo;
console.log(Four); // undefined
```

可以对变量设定默认值，这样当数组长度不足时，仍然具有想要的值。

``` javascript
var a, b;
[a = 1, b = 8] = [2];
console.log(a); // 2
console.log(b); // 8 not undefined
```

可以用过逗号分隔而不写变量名忽略掉某些数组的值。解构句法也可以从函数输出值赋值给变量。

``` javascript
function f() {
return [1, 2, 3];
}
// 忽略掉特定的值
var [a, , b] = f();
// 忽略掉所有值
[,,] = f();
```

使用 `...` 将剩余内容赋值给一个变量。

``` javascript
var [a, ...b] = [1, 2, 3];
console.log(b); // [2, 3]
```

交换变量值。

``` javascript
var a = 1;
var b = 2;
[a, b] = [b, a];
console.log(a); // 2
console.log(b); // 1
```

拉取正则表达式的匹配值

``` javascript
var url = "https://developer.mozilla.org/en-US/Web/JavaScript";
var parsedURL = /^(\w+)\:\/\/([^\/]+)\/(.*)$/.exec(url);
console.log(parsedURL);
var [, protocol, fullhost, fullpath] = parsedURL;
console.log(protocol); // "https"
```

补充：

- `RegExp.prototype.exec()` 执行对特定字符串的匹配搜索，返回数组或 `null`。`regObj.exec(str)`
- `RegExp.prototype.test()` 将正则表达式与特定字符串进行匹配，并执行搜索，返回 `true` 或 `false`。`regObj.test(str)`
- `String.prototype.search()` 执行特定字符串与正则表达式的匹配搜索，返回 `true` 或 `false`。`str.search(regexp)`
- `String.prototype.match()` 执行特定字符串与正则表达式的匹配搜索，返回数组或 `null`。`str.match(regexp)`

## 对象解构

对象的解构与数组不同的地方，最显著在于括号，数组使用 `[]`，对象使用 `{}`。基本用法为：

``` javascript
var obj = {p: 1, q: true};
var {p, q} = obj; // 变量名必须为对象的 key，否则变量值为 undefined。
```

但是也可以赋值到新变量：

``` javascript
var {p: foo, q: bar} = o;
```

如果未先声明对象，语句应该用 `()` 包裹。

``` javascript
var a, b;
({a, b} = {a:1, b:2});
```

和数组一样，对象解构的变量也可以设定默认值：

``` javascript
var {a = 10, b = 5} = {a: 3};
```

可用于设定函数的默认参数。
对嵌套对象的数组解构。`var {varname: [{element: alias}]} = obj;`
在迭代时解构对象。 `for (var {var: alias} of obj) {...}`


# JavaScript：函数

## 函数声明与函数表达式

**函数是对象，函数名是指针。**
使用不带圆括号的函数名是访问函数指针，而非调用函数。
函数表达式最后有分号 `;`。
Firefox, Opera, Chrome, Safari 通过 `name` 属性，访问函数名 `function.name`。

**函数声明提升**：在执行代码前会先读取函数声明。也就是说，可以把函数声明放在调用它的语句之后。
而对于**函数表达式**，必须等到解析器执行到它所在的代码行，才会真正被解释执行。

每个函数继承的 `toLocaleString()` 和 `toString()` 方法始终都返回函数的代码。

``` javascript
var func = function() {console.log(5)}
func.toString()
'function () {console.log(5)}'
func.toLocaleString()
'function () {console.log(5)}'
```

**匿名函数**：`function` 关键字后面没有标识符。匿名函数的 `name` 属性为空字符串。
**函数名本身就是变量**，所以函数也可以作为值来使用。函数既可作为参数传递给另一个函数，又可以将一个函数作为结果返回。
**两个特殊对象**：arguments 和 this。

## apply & call

可在特定的作用域中调用函数，等同于设置函数体内 this 对象的值。
- `apply()` 方法接受两个参数：一个是在其中运行函数的作用域，另一个是**参数数组**。第二个参数可以为 Array 实例，也可以为 arguments 对象。
- `call()` 与 apply 方法的作用相同，区别在于**接受参数的方式不同**。使用 call 时，传递给函数的参数必须**逐个列举**出来。
> 传递函数并非 apply 和 call 真正的用武之地；他们真正强大的地方是能够**扩充函数赖以运行的作用域**。使用 call 和 apply 来扩充作用域的最大好处，就是**对象不需要与方法有任何耦合关系**。

ECMAScript 5 定义了一个新方法：`bind()`。该方法会创建一个函数的实例，其 this 值会被绑定到传给 bind 函数的值。

## 递归

**递归函数**：一个函数通过名字调用自身。`arguments.callee` 是一个指向正在执行的函数的指针，可以用它来实现对函数的递归调用。在编写递归函数时，使用 `arguments.callee` 总比使用函数名更保险。但在严格模式下，不能通过脚本访问 `arguments.callee`，访问这个属性会导致错误。此时可以通过命名函数表达式来实现对当前执行的函数的引用。

``` javascript
var factorial = (function f(num) { // 命名函数表达式
if (num <= 1) {
return 1;
} else {
return num * f(num-1);
}
});
```

## 闭包

匿名函数 vs 闭包

**闭包**：有权访问**另一个函数作用域**中的**变量**的函数。在一个函数内部创建另一个函数，即可创建闭包。
理解闭包需要先理解作用域链。作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。

一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域。但是**闭包函数在执行完毕后仍然携带包含它的函数的作用域**，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多，所以**只在绝对必要时考虑使用闭包**。

作用域链的这种配置机制引出了一个值得注意的副作用，即**闭包只能取得包含函数中任何变量的最后一个值**。

### this 对象

`this` 对象是在运行时基于函数的执行环境绑定的：在全局函数中，`this` 等于 window，而当函数被作为某个对象的方法调用时，`this` 等于那个对象。匿名函数的执行环境具有全局性，因此其 `this` 对象通常指向 `window`。

每个函数在被调用时都会自动取得两个特殊变量：`this` 和 `arguments`。内部函数在搜索这两个变量时，只会搜索到其活动对象为止。因此永远不可能直接访问外部函数中的这两个变量。不过，把外部作用域中的 `this` 对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了。如果想访问作用域中的 `arguments` 对象，必须将对该对象的引用保存到另一个闭包能够访问的变量中。

**即使是细微的变化，都有可能意外改变 `this` 的值。**

### 内存泄漏

闭包在 IE9 之前的版本中会导致一些特殊的问题。如果闭包的作用域链中保存着一个 HTML 元素，那么意味着该元素将无法被销毁。 >>> 内存泄漏

## 模仿块级作用域

JS 没有块级作用域的概念。JS 从不会告诉你是否多次声明了同一个变量，它只会读后续的声明视而不见（但是它会执行后续声明中的变量初始化）。**匿名函数**可以用来模仿块级作用域并避免这个问题。

``` javascript
(function(){
// 这里是块级作用域
})();
// 这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。
```

``` javascript
var someFunction = function() {
// 这里是块级作用域
};
```

一般来说，我们都应该尽量少向全局作用域中添加变量和函数。在一个由很多开发人员共同参与的大型应用程序中，过多的全局变量和函数很容易导致命名冲突。

## 私有变量

严格来讲，JS 中没有私有成员的概念；所有对象属性都是公有的。

私有变量
- 函数中定义的变量，可以认为是私有变量，因为在函数外部无法访问这些变量。
- 私有变量包括
  - 函数的参数
  - 局部变量
  - 在函数内部定义的其他函数

可以通过闭包来创建用于访问私有变量的公有方法。

**特权方法（previleged method）**：有权访问私有变量和私有函数的公有方法。

1) 在构造函数中定义特权方法。

``` javascript
function MyObject() {
// 私有变量和私有函数
var privateVariable = 10;
function privateFunction(){
return false;
}
//特权方法
this.publicMethod = function (){
privateVariable++;
return privateFunction();
};
}
```

2) 在私有作用域中定义私有变量或函数创建特权方法。

``` javascript
(function(){
/ 私有变量和私有函数
var privateVariable = 10;
unction privateFunction(){
return false;
}
/ 构造函数
MyObject = function(){
};
/ 公有/特权方法
MyObject.prototype.publicMethod = function(){
privateVariable++;
return privateFunction();
};
)();
```

注意：在初始化未经声明的变量，总是会创建一个全局变量。但是，在严格模式下给未经声明的变量赋值会导致错误。

这个模式与在构造函数中定义特权方法的主要区别，在于**私有变量和函数是由实例共享的。**由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。

以这种方式创建静态私有变量会因为使用原型而增进代码复用，但**每个实例都没有自己的私有变量**。

3) 模块模式

单例指只有一个实例的对象。模块模式是为单例创建私有变量和特权方法。模块模式通过为单例添加私有变量和特权方法能够使其得到增强。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的。如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。

4) 增强的模块模式

**增强的模块模式**：在返回对象之前加入对其增强的代码，这种模式适合那些单例必须是某些类型的实例，同时还必须添加某些属性和（或）方法对其加以增强的情况。

来源：《JavaScript 高级程序设计 第三版》

---

# JavaScript: 编写可维护的 JS 代码

如何把一个意大利面式的代码仓库整理成一个整洁、有组织并易扩展的项目代码？

1) 分析项目：把自己当成用户去审视项目
- 使用网站所有功能，打开开发者工具，看是否有报错或输出日志。
- Node.js 项目：打开名两行接口检查 api。最好的情况是项目有一个入口，通过入口能将所有模块初始化；最坏的情况也得找到每个业务逻辑的位置。
- 找出使用的工具，阅读工具的文档，寻找最佳实践。

2) 深入了解项目
- 单元测试：测试代码的功能和方法是否按预期调用的一种方法。通过单元测试深入了解代码。

3) 创建一个规范
- 建议添加一个 .editorconfig 文件来保证代码在不同的编辑器、IDE 或不同开发者之间的编写风格一致。

4) 代码缩进
5) 命名规则
6) 尽可能使用 lint：ESlint, JSlint, JSHint。
7) 更新依赖：更新依赖需谨慎，升级依赖没有通用的处理规则。
   - `npm outdated` 可以检查哪些依赖版本比较旧

**常见单元测试框架**：karma，jasmine，macha，ava。
如果测试用户界面，可以使用 Nightwatch.js 和 Dalekjs 这类**浏览器自动测试工具**。

**单元测试与浏览器自动化测试的区别**：前者测试 JS 本身代码，保证所有的模块和通用逻辑能预期运行；后者测试项目的用户界面，保证页面上的元素在预期正确的位置。

**在重构之前先建立好单元测试。**

**架构**
- 知道项目中使用到了何种设计模式。了解该模式，并保证它在整个项目中是一致的。在项目中可以使用不同的设计模式达到不同的目的，但是**绝对不要在一个模块中使用几种不同的设计模式**。
- 如果项目中没有用到什么架构，尽早作出改变。最基本的架构层级结构分为：
  - 第三方内容
  - 模块内容
  - 数据
  - 初始化所有模块
  - 逻辑入口

**模块化**
- 把功能划分成小的模块。
- 每个模块对应一个明确的目标功能。
- 应该无法通过一个模块知道外面代码逻辑。
- 模块能在不同的场景下复用。

**写注释**
- 可用 [JSDoc] 来管理文档。

**构建有组织的提交工作流程**
- 在新分支上重构，不要在主干上直接修改

来源：
- [伯乐在线：编写可维护的 JS 代码]

## 个人总结

- 了解和分析项目
- 建立代码规范
- 注释和管理文档
- 管理依赖
- 重构前进行单元测试
- 了解设计模式
- 模块化
- 良好的版本控制流程习惯

# CSS 和 JS 加载顺序和位置问题

## 为什么要把 CSS 样式表放在头部（Head）

如果 CSS 放置在头部，页面会渐进渲染。前端工程师需要让页面和样式渐进的显示出来。对于具有大量内容的页面和网络连接效率较低的用户，这是非常重要的。这样可以给用户视觉反馈，来提示页面的渲染进度。这能够整体上提升用户体验。

如果 CSS 防止在页面文档的底端，这会阻止浏览器渐进的渲染页面。浏览器会阻止渲染，为了避免对页面元素进行重绘。这样会出现一段时间的白屏。影响用户体验。

## 为什么要把 JS 脚本放在底端（the Bottom of Body）

脚本文件的加载会阻塞并行下载。HTTP/1.1 规定浏览器对于同一个主机的并行下载请求不能超过两个。如果网站图片资源放在多个主机上，那么可以同时超过两个下载请求。但是脚本文件会使浏览器停止其他数据的下载，不同主机的下载都会停止。

但是在某些情况下，并不能将 JS 脚本放在底端。例如，脚本中包含有使用 `document.write` 插入部分页面内容，这就不能放在后面加载。

替代的做法是，使用 `defer` 加载脚本，这样就可以放在头部了。`defer` 属性表明了脚本并不包含 `document.write`，在加载脚本的同时，页面也一同渲染。Firefox 并不支持 `defer` 属性。

## 如果 script 和 link 都在头部，谁在前，谁在后？

对于现代**桌面**浏览器来说，CSS 在 JS 前声明对性能并没有显著提高。甚至，CSS 在 JS 之后，不但不影响性能，反而在特定情况下还能提升性能。不过，这仅限于现代桌面浏览器。对于老式浏览器，仍然需要在 JS 之前声明 CSS 的外部链接。这归功于现代桌面浏览器使用了“推测渲染技术”（speculative parsing），这种技术能够让浏览器往前一步看，总是在脚本下载和执行之前下载其他资源。老式浏览器并不支持该技术，所以把脚本放在前面会影响性能。

目前，85% 的桌面浏览器均支持推测渲染技术。把脚本放在样式表之前仍然可能会影响 15% 的用户。对于移动端的浏览器，无法获得一个明确的支持该技术的比例。WebKit 内核的移动浏览器已支持该技术。但是即便是最新的 WebKit 内核浏览器，[josh3736]仍然发现 JS 在 CSS 之前会影响性能，这可能与移动设备在 CPU，内存以及网络上的限制而关闭了限制了该功能。

参考资料：

- [stackoverflow: Where should I put the CSS and Javascript code in an HTML webpage?]
- [stackoverflow: Is the recommendation to include CSS before JavaScript invalid?]
- [stackoverflow: Group of CSS and JS files import at HTML?]
- [Yahoo! Best Practices for Speeding Up Your Web Site]

