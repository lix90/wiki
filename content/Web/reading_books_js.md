---
title: "Reading Books of JavaScript"
author: lixiang
date: 2017-03-22 20:57
updated: 2017-03-27 22:23
tag: javascript, node.js
---

# Eloquent JS (2015)

六种类型数值：numbers, strings, booleans, objects, functions, undefined values
javascript 最高使用 64bits 存储单个数值，达到 2^64 个数字，18*10^18，实际上只有 9*10^15 个数字。
三种特殊数字：Infinite, -Infinite, NaN
两种未定义值：null, undefined

# Node.JS 开发指南 #

实时Web应用开发
Node.js让JavaScript运行在服务器端上，浏览器之外。
Node.js将“HTTP服务器”这一层抽离，直接面向浏览器用户。

## 异步式I/O与事件式编程

异步事件模式的有缺点有哪些？

事件队列
事件循环

阻塞与阻塞式 I/O：
> 线程在执行中遇到如磁盘读写或网络通信等耗时较长的操作，操作系统会剥夺这个线程的CPU控制权，使其暂停执行，同时将资源让给其他的工作线程。当I/O操作完毕时，操作系统将这个线程的阻塞状态解除，恢复其对CPU的控制权，使其继续执行后续的代码。

> 当线程遇到 I/O 操作时，不会以阻塞的方式等待 I/O 操作 的完成或数据的返回，而只是将 I/O 请求发送给操作系统，继续执行下一条语句。当操作 系统完成 I/O 操作时，以事件的形式通知执行 I/O 操作的线程，线程会在特定时候处理这个 事件。为了处理异步 I/O，线程必须有事件循环，不断地检查有没有未处理的事件，依次予 以处理。

异步式 I/O 少了多线程的开销。

> 对操作系统来说，创建一个线程的代价是十分昂贵的， 需要给它分配内存、列入调度，同时在线程切换的时候还要执行内存换页，CPU 的缓存被 清空，切换回来的时候还要重新从内存中读取信息，破坏了数据的局部性。

| 同步式或阻塞式 I/O | 异步式或非阻塞式 I/O |
|:-----------------|:-------------------|
利用多线程提供吞吐量 | 单线程即可实现高吞吐量
通过事件片分割和线程调度利用多核CPU | 通过功能划分利用多核CPU
需要由操作系统调度多线程使用多核 CPU | 可以将单进程绑定到单核 CPU
难以充分利用 CPU 资源 | 可以充分利用 CPU 资源
内存轨迹大，数据局部性弱 | 内存轨迹小，数据局部性强
符合线性的编程思维 | 不符合传统编程思维

## Node.js 的事件循环机制

### 进程与线程

>线程：thread，操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。

>操作系统的设计，因此可以归结为三点：
>（1）以多进程形式，允许多个任务同时运行；
>（2）以多线程形式，允许单个任务分成不同的部分运行；
>（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。
> http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html

### Event Loop

Event Loop是一个程序结构，用于等待和发送消息和事件。

在程序中设置两个线程：一个负责程序本身的运行，称为"主线程"；另一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为"Event Loop线程"（可以译为"消息线程"）。

[Understanding the Node.js Event Loop - Node.js at Scale](https://blog.risingstack.com/node-js-at-scale-understanding-node-js-event-loop/)

## CommonJS

为了统一JavaScript在浏览器之外的实现，CommonJS诞生了。

## require & exports

> exports 本身仅仅是一个普通的空对象，即 {}，它专门用来声明接口，本质上是通过它为模块闭包 的内部建立了一个有限的访问接口。因为它没有任何特殊的地方，所以可以用其他东西来代替。

> exports 实际上只是一个和 module.exports 指向同一个对象的变量， 它本身会在模块执行结束后释放，但 module 不会，因此只能通过指定 module.exports 来改变访问接口。

> 如果把包安装到全局，可以提高程序的重复利用程度，避免同样的内容的多 份副本，但坏处是难以处理不同的版本依赖。如果把包安装到当前目录， 或者说本地，则不会有不同程序依赖不同版本的包的冲突问题，同时还减 轻了包作者的 API 兼容性压力，但缺陷则是同一个包可能会被安装许多次。

> 使用全局模式安装的包并不能直接在 JavaScript 文件中用 require 获得，因为 require 不会搜索 /usr/local/lib/node_modules/。npm 提供了一个有趣的命令 npm link，它的功能是在本地包和全局包之间创建符号链 接。
## 核心模块

### 全局对象 ###

- javascript -> window
- node.js -> global

global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条件的变量为全局变量：
- 在最外层定义的变量；
- 全局对象的属性；
- 隐式定义的变量（为定义直接赋值的变量）。

在 nodejs 不可能在最外层定义变量。

#### process

用于描述当前 nodejs 进程状态的对象，提供了一个与操作系统的简单接口。

### 常用工具 ###
