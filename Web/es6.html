<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/colorful.css">
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/style.css">
    <link rel="shortcut icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>ES6/ES2015 - Wiki by Lixiang</title>
    <meta name="keywords" content="wiki, r, python, data science, matlab, emacs, learning"/>
    <meta name="description" content="Lixiang's personal Wiki, powered by emacs and markdown."/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
  </head>

  <body>
    <div id="container" class="typo">
      
<div id="header">
  <div id="post-nav">
    <a href="/wiki/">Wiki by Lixiang</a>
    &nbsp;&#187;&nbsp;
    <a href="/wiki/#Web">Web</a>
    &nbsp;&#187;&nbsp;ES6/ES2015
    <span class="updated">Updated&nbsp;
    2017-03-28 15:09
    </span>
  </div>
</div>
<div class="clearfix"></div>
<div id="content">
  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">块级作用域变量</a></li>
<li><a href="#iife">立即执行函数表达式（IIFE）</a></li>
<li><a href="#_2">文本模版</a></li>
<li><a href="#_3">解构赋值</a></li>
<li><a href="#_4">类和对象</a></li>
<li><a href="#_5">继承</a></li>
<li><a href="#promise">原生 Promise</a></li>
<li><a href="#_6">箭头函数</a></li>
<li><a href="#forof">使用 for...of 迭代</a></li>
<li><a href="#_7">参数</a></li>
</ul>
</div>
<h1 id="_1">块级作用域变量</h1>
<p><strong>let/const</strong> vs. <strong>var</strong></p>
<p>var 进行变量声明时会泄露到其它代码块，如 for 循环或者是 if 块。</p>
<p>var 提升：
- var 是在函数作用域中的：即使在声明前，它在整个函数内均可用；
- 声明被提升了：变量在声明前就可以使用了；
- 初始化没有被提升：如果使用 var，一定要在顶部声明变量。</p>
<p>let 提升与 temporal dead zone：
- 在 ES6 中，let 会将变量提升到块顶部，而非如 ES5 提升至函数顶部；
- 在变量声明前引用变量会造成 ReferenceError；
- let 是块级作用域的，不可以在声明前使用；
- temporal dead zone 是块开始到变量被声明的这段区域。</p>
<p>声明常量可以使用 const。</p>
<h1 id="iife">立即执行函数表达式（IIFE）</h1>
<p>为了防止变量的泄露，避免污染全局环境，需要使用 IIFE 将代码包起来。在 ES6 中，不再需要使用 IIFE，只要用块和 let 便可。</p>
<h1 id="_2">文本模版</h1>
<p>需要文本模版，ES6 不需要使用嵌套连接，该用反引号 (`) 和字符串插值 ${}。</p>
<p>多行字符串则不需要再连接 n 字符串了。</p>
<h1 id="_3">解构赋值</h1>
<ul>
<li>获取数组元素</li>
<li>调换值</li>
<li>返回多个值的解构</li>
<li>参数匹配解构</li>
<li>深度匹配</li>
</ul>
<p>对于多返回值的情况，不要用数组解构，用对象解构。</p>
<h1 id="_4">类和对象</h1>
<p>在 ES5 中利用构造函数实现以面向对象编程的方式创建对象。ES6 则提供了语法糖，可以用 class、constructor 等新的关键字、更少的样板代码实现相同的效果。</p>
<ul>
<li>最好使用 class 语法，避免直接操作 prototype，这样使得代码更佳简明易懂；</li>
<li>避免出现空的构造器：如果没有指明，类会有默认的构造器的。</li>
</ul>
<h1 id="_5">继承</h1>
<p>ES6 提供了新的关键字 extends 和 super，其原型继承方式比 ES5 简洁了许多。</p>
<h1 id="promise">原生 Promise</h1>
<p>promise 中可以用 then 在某个函数完成后执行新的代码，而不必再嵌套函数。</p>
<h1 id="_6">箭头函数</h1>
<p>在ES5 中，函数内需要用临时变量指向 this 或者使用 bind 绑定。ES6 中可以使用箭头函数解决 this 指向问题。箭头函数会捕捉其所在上下文的 this 值，作为自己的 this 值。</p>
<p>箭头函数的引入有两个方面的影响：
- 更简短的函数书写；
- 对 this 的词法解析。</p>
<h1 id="forof">使用 for...of 迭代</h1>
<p>for --&gt; forEach --&gt; for...of</p>
<h1 id="_7">参数</h1>
<p>默认参数：ES6 中可以指定 default parameters 的值。
剩余参数：ES6 中可以用展开操作符 ... 实现剩余参数</p>
<hr />
<p>参考资料：</p>
<ul>
<li>http://web.jobbole.com/88910/</li>
<li>ECMAScript 6 入门 http://es6.ruanyifeng.com/</li>
</ul>
  
  <div class="relation">
    Related:
    <ul>
  
    <li><a href="/wiki/Web/algorithm.html">算法</a></li>
  
    <li><a href="/wiki/Web/reading_books_js.html">Reading Books of JavaScript</a></li>
  
    </ul>
  </div>
  
</div>
    </div>
    <div id="footer">
      <div class="footer-left">
        <p>
        Copyright © 2017 Lixiang.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
        Theme by <a href="https://git.coding.net/tankywoo/yasimple_x2.git" target="_blank">YASimple_X2</a>.
        </p>
      </div> <!-- end footer-left -->
      <div class="footer-right">
        <p>Site Generated 2017-07-06 18:24:12</p>
      </div> <!-- end footer-right -->
    </div>

    
    
  </body>
</html>