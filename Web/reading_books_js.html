<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/colorful.css">
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/style.css">
    <link rel="shortcut icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>Reading Books of JavaScript - Wiki by Lixiang</title>
    <meta name="keywords" content="wiki, r, python, data science, matlab, emacs, learning"/>
    <meta name="description" content="Lixiang's personal Wiki, powered by emacs and markdown."/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
  </head>

  <body>
    <div id="container" class="typo">
      
<div id="header">
  <div id="post-nav">
    <a href="/wiki/">Wiki by Lixiang</a>
    &nbsp;&#187;&nbsp;
    <a href="/wiki/#Web">Web</a>
    &nbsp;&#187;&nbsp;Reading Books of JavaScript
    <span class="updated">Updated&nbsp;
    2017-03-27 22:23
    
    </span>
  </div>
</div>
<div class="clearfix"></div>
<div id="content">
  <h1 id="eloquent-js-2015">Eloquent JS (2015)</h1>
<p>六种类型数值：numbers, strings, booleans, objects, functions, undefined values
javascript 最高使用 64bits 存储单个数值，达到 2^64 个数字，18<em>10^18，实际上只有 9</em>10^15 个数字。
三种特殊数字：Infinite, -Infinite, NaN
两种未定义值：null, undefined</p>
<h1 id="nodejs">Node.JS 开发指南</h1>
<p>实时Web应用开发
Node.js让JavaScript运行在服务器端上，浏览器之外。
Node.js将“HTTP服务器”这一层抽离，直接面向浏览器用户。</p>
<h2 id="io">异步式I/O与事件式编程</h2>
<p>异步事件模式的有缺点有哪些？</p>
<p>事件队列
事件循环</p>
<p>阻塞与阻塞式 I/O：</p>
<blockquote>
<p>线程在执行中遇到如磁盘读写或网络通信等耗时较长的操作，操作系统会剥夺这个线程的CPU控制权，使其暂停执行，同时将资源让给其他的工作线程。当I/O操作完毕时，操作系统将这个线程的阻塞状态解除，恢复其对CPU的控制权，使其继续执行后续的代码。</p>
<p>当线程遇到 I/O 操作时，不会以阻塞的方式等待 I/O 操作 的完成或数据的返回，而只是将 I/O 请求发送给操作系统，继续执行下一条语句。当操作 系统完成 I/O 操作时，以事件的形式通知执行 I/O 操作的线程，线程会在特定时候处理这个 事件。为了处理异步 I/O，线程必须有事件循环，不断地检查有没有未处理的事件，依次予 以处理。</p>
</blockquote>
<p>异步式 I/O 少了多线程的开销。</p>
<blockquote>
<p>对操作系统来说，创建一个线程的代价是十分昂贵的， 需要给它分配内存、列入调度，同时在线程切换的时候还要执行内存换页，CPU 的缓存被 清空，切换回来的时候还要重新从内存中读取信息，破坏了数据的局部性。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">同步式或阻塞式 I/O</th>
<th align="left">异步式或非阻塞式 I/O</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">利用多线程提供吞吐量</td>
<td align="left">单线程即可实现高吞吐量</td>
</tr>
<tr>
<td align="left">通过事件片分割和线程调度利用多核CPU</td>
<td align="left">通过功能划分利用多核CPU</td>
</tr>
<tr>
<td align="left">需要由操作系统调度多线程使用多核 CPU</td>
<td align="left">可以将单进程绑定到单核 CPU</td>
</tr>
<tr>
<td align="left">难以充分利用 CPU 资源</td>
<td align="left">可以充分利用 CPU 资源</td>
</tr>
<tr>
<td align="left">内存轨迹大，数据局部性弱</td>
<td align="left">内存轨迹小，数据局部性强</td>
</tr>
<tr>
<td align="left">符合线性的编程思维</td>
<td align="left">不符合传统编程思维</td>
</tr>
</tbody>
</table>
<h2 id="nodejs_1">Node.js 的事件循环机制</h2>
<h3 id="_1">进程与线程</h3>
<blockquote>
<p>线程：thread，操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。</p>
<p>操作系统的设计，因此可以归结为三点：
（1）以多进程形式，允许多个任务同时运行；
（2）以多线程形式，允许单个任务分成不同的部分运行；
（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。
http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html</p>
</blockquote>
<h3 id="event-loop">Event Loop</h3>
<p>Event Loop是一个程序结构，用于等待和发送消息和事件。</p>
<p>在程序中设置两个线程：一个负责程序本身的运行，称为"主线程"；另一个负责主线程与其他进程（主要是各种I/O操作）的通信，被称为"Event Loop线程"（可以译为"消息线程"）。</p>
<p><a href="https://blog.risingstack.com/node-js-at-scale-understanding-node-js-event-loop/">Understanding the Node.js Event Loop - Node.js at Scale</a></p>
<h2 id="commonjs">CommonJS</h2>
<p>为了统一JavaScript在浏览器之外的实现，CommonJS诞生了。</p>
<h2 id="require-exports">require &amp; exports</h2>
<blockquote>
<p>exports 本身仅仅是一个普通的空对象，即 {}，它专门用来声明接口，本质上是通过它为模块闭包 的内部建立了一个有限的访问接口。因为它没有任何特殊的地方，所以可以用其他东西来代替。</p>
<p>exports 实际上只是一个和 module.exports 指向同一个对象的变量， 它本身会在模块执行结束后释放，但 module 不会，因此只能通过指定 module.exports 来改变访问接口。</p>
<p>如果把包安装到全局，可以提高程序的重复利用程度，避免同样的内容的多 份副本，但坏处是难以处理不同的版本依赖。如果把包安装到当前目录， 或者说本地，则不会有不同程序依赖不同版本的包的冲突问题，同时还减 轻了包作者的 API 兼容性压力，但缺陷则是同一个包可能会被安装许多次。</p>
<p>使用全局模式安装的包并不能直接在 JavaScript 文件中用 require 获得，因为 require 不会搜索 /usr/local/lib/node_modules/。npm 提供了一个有趣的命令 npm link，它的功能是在本地包和全局包之间创建符号链 接。</p>
</blockquote>
<h2 id="_2">核心模块</h2>
<h3 id="_3">全局对象</h3>
<ul>
<li>javascript -&gt; window</li>
<li>node.js -&gt; global</li>
</ul>
<p>global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条件的变量为全局变量：
- 在最外层定义的变量；
- 全局对象的属性；
- 隐式定义的变量（为定义直接赋值的变量）。</p>
<p>在 nodejs 不可能在最外层定义变量。</p>
<h4 id="process">process</h4>
<p>用于描述当前 nodejs 进程状态的对象，提供了一个与操作系统的简单接口。</p>
<h3 id="_4">常用工具</h3>
  
  <div class="relation">
    Related:
    <ul>
  
    <li><a href="/wiki/Web/algorithm.html">算法</a></li>
  
    <li><a href="/wiki/Web/es6.html">ES6/ES2015</a></li>
  
    </ul>
  </div>
  
</div>
    </div>
    <div id="footer">
      <div class="footer-left">
        <p>
        Copyright © 2017 Lixiang.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
        Theme by <a href="https://git.coding.net/tankywoo/yasimple_x2.git" target="_blank">YASimple_X2</a>.
        </p>
      </div> <!-- end footer-left -->
      <div class="footer-right">
        <p>Site Generated 2017-04-13 10:50:46</p>
      </div> <!-- end footer-right -->
    </div>

    
    
  </body>
</html>